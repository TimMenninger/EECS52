MODULE Jukebox

TITLE 'Jukebox CPLD'


" Jukebox Interface  DEVICE  'ISPLSI1016'


" Description:  Interfaces the LCD Display, IDE and digital potentiometer.
"               It assumes the CPU is running on a 24 MHz clock.  CPU assumed
"               to be 80C188XL.
"
"               Display: This interfaces the NHD-0420DZ-FSW-FBW display, which
"               is 4 lines by 20 characters in size.  To write to the display,
"               there is a data latch whose enable and direction are controlled
"               by the CPLD.  The CPLD uses the WR and PCS signals from the CPU
"               to execute display writing.  To read from the display, the RD
"               and PCS are used and the CPLD reverses the direction on the
"               data latch.
"
"               IDE: This only reads from IDE.  The IDE sends 16 bits of data
"               to a 74FCT16646, which latches it all.  The CPLD controls when
"               the high and low byte of this data are read by dictating the
"               enable and direction of dataflow on the 74FCT16646.
"
"               Digital Potentiometer: This increases and decreases the voltage
"               at the wiper terminal using the data input from the CPU.  The
"               data is the low bit.  1 increments and 0 decrements.  This 
"		machine works by always sending a 1 and a 0.  Which comes first
"		is determined by the operation (inc or dec).
"

" Revision History:
" 02/12/16      Created with functionality for 4x20 Display, IDE interface and
"                   digital potentiometer.



" Pins

"GND   pin   1;                  supply  power ground
"      pin   2;                  input   unused (IN3)
DSPCS  pin   3   ISTYPE 'com';  "output  Chip select to display
DATAE  pin   4   ISTYPE 'com';  "output  Enable of CPU-Display data latch (active low)
"      pin   5                   unused  (I/O26)  
"      pin   6                   unused  (I/O27)
"      pin   7                   unused  (I/O28)
"      pin   8                   unused  (I/O29)
!MCS0  pin   9;                 "input   IDE chip select from 80C188
"      pin   10                  unused  (I/O31)
Clock  pin   11;                "input   24 MHz clock
"VCC   pin   12                  supply  power Vcc
"ISPEN pin   13                  input   Tied high
"      pin   14                  unused  (IN0/SDI)
!PCS1  pin   15;                "input   Digital potentiometer chip select from 80C188
AD0    pin   16;                "input   Tells us even or odd address, used for digital pot
"      pin   17;                 unused  (I/O2)
"      pin   18;                 unused  (I/O3)
"      pin   19;                 unused  (I/O4)
"      pin   20;                 unused  (I/O5)
SAB    pin   21  ISTYPE 'com';  "output  xSAB and xSBA for IDE interface
IDECS1 pin   22  ISTYPE 'com';  "input   IDE CS1 pin
"GND   pin   23                  supply  power ground
"      pin   24                  unused  (IN1/SD0)
DIR    pin   25  ISTYPE 'com';  "output  DIR for IDE interface
SCLK   pin   26  ISTYPE 'com';  "output  CLK for IDE latching
!WR    pin   27;                "input   Write (active low from 80C188)
!RD    pin   28;                "input   Read (active low from 80C188)
!PCS5  pin   29;                "input   Display chip select from 80C188
"      pin   30                  unused  (I/O13)
IDEE   pin   31  ISTYPE 'com';  "output  E1 to 74FCT16646
IDEE2  pin   32  ISTYPE 'com';  "output  E2 to 74FCT16646
"      pin   33                  unused  (Y2/SCLK)
"VCC   pin   34                  supply  power Vcc
"RESET pin   35;                 input   Reset (active high from 80C188)
SRDY   pin   37  ISTYPE 'com';  "output  synchronous ready to 80C188
ORD    pin   38  ISTYPE 'com';  "output  Read signal sent to peripheral chips
RESET  pin   39;		"input   Active high reset from 80C188
IDECS  pin   40  ISTYPE 'com';  "output  CS0 to IDE
DA2    pin   41  ISTYPE 'com';  "output  DA2 to IDE, E to Display
DA1    pin   42  ISTYPE 'com';  "output  DA1 to IDE, xSAB xSBA to 74FCT16646
DA0    pin   43  ISTYPE 'com';  "output  DA0 to IDE, xDIR to 74FCT16646, DIR to Display Data Latch,
                                "            Data to Digital Potentiometer
POTCS  pin   44  ISTYPE 'com';  "output  Chip select to digital potentiometer


" General registers
RDWR   pin       ISTYPE 'reg';  "keeps track of whether we are reading (0) or writing (1)


" State bits

St0    pin       ISTYPE 'reg';  "output  state bit 0
St1    pin       ISTYPE 'reg';  "output  state bit 1
St2    pin       ISTYPE 'reg';  "output  state bit 2
St3    pin    	 ISTYPE 'reg';  "output  state bit 3
St4    pin       ISTYPE 'reg';  "output  state bit 4
St5    pin       ISTYPE 'reg';  "output  state bit 5



"the states

StateBits  =  [ St5, St4, St3, St2, St1, St0 ]; " state bits
                                      		" state assignments
" Start state
Idle       =  [   0,   0,   0,   0,   0,   0 ]; " idle state (waiting for a cycle to start)

" Display states
DispSt     =  [   1,   0,   0,   0,   0,   0 ]; " start of display access cycle
DispWt1    =  [   1,   0,   0,   0,   0,   1 ]; " wait state 1 (so E cycle is 460 ns long)
DispWt2    =  [   1,   0,   0,   0,   1,   1 ]; " wait state 2
DispWt3    =  [   1,   0,   0,   0,   1,   0 ]; " wait state 3
DispWt4    =  [   1,   0,   0,   1,   1,   0 ]; " wait state 4
DispWt5    =  [   1,   0,   0,   1,   0,   0 ]; " wait state 5
DispWt6    =  [   1,   0,   0,   1,   0,   1 ]; " wait state 6
DispDisE   =  [   1,   0,   0,   1,   1,   1 ]; " begins data hold period
DispStop   =  [   1,   0,   1,   1,   1,   1 ]; " stops write cycle, CPU responsible for 1200 ns wait

" IDE read states
IDERdLow   =  [   0,   1,   0,   0,   0,   0 ]; " starts reading low byte from IDE/hard drive
HDRdSt     =  [   0,   1,   0,   0,   0,   1 ]; " sets read signal high to start data read
HDLatchRd  =  [   0,   1,   1,   0,   0,   1 ]; " latches the high byte of data onto IDE decoder
HDStopRd   =  [   0,   1,   1,   0,   0,   0 ]; " stops read signal to wrap up data transfer from HD to IDE decoder
HDWaitSt   =  [   0,   1,   1,   1,   0,   0 ]; " waits so the data hold is observed
IDERdHigh  =  [   0,   0,   1,   0,   0,   0 ]; " starts reading high byte from IDE decoder

" Digital potentiometer states
DigPotSt   =  [   0,   0,   0,   1,   0,   0 ]; " creates standard that tells pot if inc or dec operation
DigPotEna  =  [   0,   0,   1,   1,   0,   0 ]; " enables digital potentiometer/waits to do next pulse
DigPotUp   =  [   0,   0,   1,   1,   1,   0 ]; " pulses a 1 to the potentiometer data pin
DigPotDown =  [   0,   0,   1,   1,   0,   1 ]; " pulses a 0 to the potentiometer data pin




EQUATIONS


" Output enables - enable the used outputs (registered outputs enabled by OE\ pin)
SRDY.OE  = 1;
DSPCS.OE = 1;
POTCS.OE = 1;
DATAE.OE = 1;
IDEE.OE  = 1;
IDEE2.OE = 1;
ORD.OE   = 1;
IDECS.OE = 1;
IDECS1.OE= 1;
DA2.OE   = 1;
DA1.OE   = 1;
DA0.OE   = 1;
SCLK.OE	 = 1;
DIR.OE   = 1;
SAB.OE   = 1;


" clocks for the registered outputs
StateBits.CLK  =  Clock;        " use the global clock pin
RDWR.CLK = Clock;		" use global clock



STATE_DIAGRAM  StateBits        " a Mealy state machine


STATE  Idle:                    " Wait idly with nothing enabled

    " Turn off all chip selects
    DSPCS = 0;                  " Disable chip select to display
    POTCS = 1;                  " Disable chip select to digital potentiometer
    DATAE = 1;                  " Disable latching data
    IDEE  = 1;                  " Disable IDE decoder
    IDEE2 = 1;			" Disable IDE decoder
    IDECS = 1;                  " Disable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    " Define these for good measure, but are disregarded by peripherals w/o CS
    ORD = 0;                    " Read output used as active low write by Display
    DA2 = 0;                    " Data to IDE
    DA1 = 0;                    " Data to IDE
    DA0 = 0;			" Data to IDE
    SCLK = 0;
    DIR = 0;
    SAB = 0;
    
    SRDY = 1;                   " SRDY always 'ready' in this state
 
  	 IF (RESET)	    THEN Idle      WITH RDWR = 0  " On reset do nothing
    ELSE IF (PCS5 & WR)     THEN DispSt    WITH RDWR = 0  " DA0 puts latch direction toward display
    ELSE IF (PCS5 & RD)     THEN DispSt    WITH RDWR = 1  " DA0 puts latch direction toward CPU
    ELSE IF (MCS0 & AD0)    THEN IDERdHigh WITH RDWR = 0  " Odd address, read high byte
    ELSE IF (MCS0 & !AD0)   THEN IDERdLow  WITH RDWR = 0  " Even address, read low byte
    ELSE IF (PCS1)	    THEN DigPotSt  WITH RDWR = 0  " Increment or decrement digital pot
    ELSE                         Idle      WITH RDWR = 0; " otherwise just stay here
    


" Following states correspond to writing to display
    
STATE DispSt:                   " Begin display write cycle

    " Turn off all chip selects except one for display.
    DSPCS = 0;                  " Chip select to display
    POTCS = 1;                  " Disable chip select to digital potentiometer
    DATAE = 0;                  " Begin latching data for display
    IDEE  = 1;                  " Disable IDE decoder
    IDEE2 = 1;			" Disable IDE decoder
    IDECS = 1;                  " Disable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = !RDWR;                " Read output is active low write for display
    DA2 = 1;                    " Used by display as enable
    DA1 = 0;                    " Data to IDE not used
    DA0 = RDWR;			" Define the direction of data on the latch
    
    SRDY = 0;                   " Not ready when writing to display
    
         IF (RESET)     THEN Idle       "Reset, stop displaying.
    ELSE                     DispWt1    "Next state enables data latch
    
    
STATE DispWt1:                  " Begin waiting while display sets up

    " Turn off all chip selects except one for display.
    DSPCS = 0;                  " Chip select to display
    POTCS = 1;                  " Disable chip select to digital potentiometer
    DATAE = 1;                  " Latch data from 80C188
    IDEE  = 1;                  " Disable IDE decoder
    IDEE2 = 1;			" Disable IDE decoder
    IDECS = 1;                  " Disable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = !RDWR;                " Read output is active low write for display
    DA2 = 1;                    " Used by display as enable
    DA1 = 0;                    " Data to IDE not used
    DA0 = RDWR;			" Define direction of display data latch
    
    SRDY = 0;                   " Not ready when writing to display
    
         IF (RESET)     THEN Idle       "Reset, stop displaying.
    ELSE                     DispWt2    "Continue waiting
    
    
STATE DispWt2:                  " Continue waiting while display sets up

    " Turn off all chip selects except one for display.
    DSPCS = 0;                  " Chip select to display
    POTCS = 1;                  " Disable chip select to digital potentiometer
    DATAE = 1;                  " Data latched from 80C188
    IDEE  = 1;                  " Disable IDE decoder
    IDEE2 = 1;			" Disable IDE decoder
    IDECS = 1;                  " Disable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = !RDWR;                " Read output is active low write for display
    DA2 = 1;                    " Used by display as enable
    DA1 = 0;                    " Data to IDE not used
    DA0 = RDWR;			" Define direction of display data latch
    
    SRDY = 0;                   " Not ready when writing to display
    
         IF (RESET)     THEN Idle       "Reset, stop displaying.
    ELSE                     DispWt3    "Continue waiting
    
    
STATE DispWt3:                  " Continue waiting while display sets up

    " Turn off all chip selects except one for display.
    DSPCS = 0;                  " Chip select to display
    POTCS = 1;                  " Disable chip select to digital potentiometer
    DATAE = 1;                  " Data latched from 80C188
    IDEE  = 1;                  " Disable IDE decoder
    IDEE2 = 1;			" Disable IDE decoder
    IDECS = 1;                  " Disable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = !RDWR;                " Read output is active low write for display
    DA2 = 1;                    " Used by display as enable
    DA1 = 0;                    " Data to IDE not used
    DA0 = RDWR;			" Define direction of display data latch
    
    SRDY = 0;                   " Not ready when writing to display
    
         IF (RESET)     THEN Idle       "Reset, stop displaying.
    ELSE                     DispWt4    "Continue waiting
    
    
STATE DispWt4:                  " Continue waiting while display sets up

    " Turn off all chip selects except one for display.
    DSPCS = 0;                  " Chip select to display
    POTCS = 1;                  " Disable chip select to digital potentiometer
    DATAE = 1;                  " Data latched from 80C188
    IDEE  = 1;                  " Disable IDE decoder
    IDEE2 = 1;			" Disable IDE decoder
    IDECS = 1;                  " Disable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = !RDWR;                " Read output is active low write for display
    DA2 = 1;                    " Used by display as enable
    DA1 = 0;                    " Data to IDE not used
    DA0 = RDWR;			" Define direction of display data latch
    
    SRDY = 0;                   " Not ready when writing to display
    
         IF (RESET)     THEN Idle       "Reset, stop displaying.
    ELSE                     DispWt5    "Continue waiting
    
    
STATE DispWt5:                  " Continue waiting while display sets up

    " Turn off all chip selects except one for display.
    DSPCS = 0;                  " Chip select to display
    POTCS = 1;                  " Disable chip select to digital potentiometer
    DATAE = 1;                  " Data latched from 80C188
    IDEE  = 1;                  " Disable IDE decoder
    IDEE2 = 1;			" Disable IDE decoder
    IDECS = 1;                  " Disable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = !RDWR;                " Read output is active low write for display
    DA2 = 1;                    " Used by display as enable
    DA1 = 0;                    " Data to IDE not used
    DA0 = RDWR;			" Define direction of display data latch
    
    SRDY = 0;                   " Not ready when writing to display
    
         IF (RESET)     THEN Idle       "Reset, stop displaying.
    ELSE                     DispWt6    "Continue waiting
    
    
STATE DispWt6:                  " Continue waiting while display sets up

    " Turn off all chip selects except one for display.
    DSPCS = 0;                  " Chip select to display
    POTCS = 1;                  " Disable chip select to digital potentiometer
    DATAE = 1;                  " Data latched from 80C188
    IDEE  = 1;                  " Disable IDE decoder
    IDEE2 = 1;			" Disable IDE decoder
    IDECS = 1;                  " Disable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = !RDWR;                " Read output is active low write for display
    DA2 = 1;                    " Used by display as enable
    DA1 = 0;                    " Data to IDE not used
    DA0 = RDWR;			" Define direction of display data latch
    
    SRDY = 0;                   " Not ready when writing to display
    
         IF (RESET)     THEN Idle       "Reset, stop displaying.
    ELSE                     DispDisE   "Disable display to start data hold
    
    
STATE DispDisE:                 " Disable display to start data hold

    " Turn off all chip selects except one for display.
    DSPCS = 0;                  " Chip select to display
    POTCS = 1;                  " Disable chip select to digital potentiometer
    DATAE = 1;                  " Data latched from 80C188
    IDEE  = 1;                  " Disable IDE decoder
    IDEE2 = 1;			" Disable IDE decoder
    IDECS = 1;                  " Disable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = !RDWR;                " Read output is active low write for display
    DA2 = 0;                    " Used by display as enable.  Disabling here
    DA1 = 0;                    " Data to IDE not used
    DA0 = RDWR;			" Define direction of display data latch
    
    SRDY = 0;                   " Not ready when writing to display
    
         IF (RESET)     THEN Idle       "Reset, stop displaying.
    ELSE                     DispStop   "Done displaying other than enable cycle
    
    
STATE DispStop:                 " Stops display cycle.  Enable cycle assumed to be observed by CPU

    " Turn off all chip selects
    DSPCS = 1;                  " Disable chip select to display
    POTCS = 1;                  " Disable chip select to digital potentiometer
    DATAE = 1;                  " Data still latched from 80C188
    IDEE  = 1;                  " Disable IDE decoder
    IDEE2 = 1;			" Disable IDE decoder
    IDECS = 1;                  " Disable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = !RDWR;                " Read output is active low write for display
    DA2 = 0;                    " Used by display as enable.  Disabling here
    DA1 = 0;                    " Data to IDE not used
    DA0 = RDWR;			" Keep data at latch for reference
    
    SRDY = 1;                   " SRDY can be set now that we are done accessing display
    
         IF (RESET)            	THEN Idle       "Reset, stop displaying.
    ELSE IF (PCS5 & (RD # WR)) 	THEN DispStop   "Require PCS rising edge to start cycle
    ELSE                     	     Idle       "Go back to beginning




" State definitions for IDE operations

STATE IDERdLow:			" Starts IDE read cycle to read low byte

    " Turn off all chip selects except IDE to get info from hard drive
    DSPCS = 1;                  " Disable chip select to display
    POTCS = 1;                  " Disable chip select to digital potentiometer
    DATAE = 1;                  " Disable data latch from display
    IDEE  = 0;                  " IDE Decoder passes low byte through while enabled
    IDEE2 = 1;			" IDE Decoder stores high byte while disabled
    IDECS = 0;                  " Chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = 0;                    " Not high yet because delay after valid address before expected
    DA2 = 0;                    " DA2 = 0 for read
    DA1 = 0;                    " DA1 = 0 for read
    DA0 = 0;			" DA0 = 0 for read
    DIR = 0;			" Direction from IDE to CPU
    SCLK = 0;			" Do not latch yet
    SAB = 0;			" Real time low byte data to bus
    
    SRDY = 0;                   " Not ready when reading from HD
    
         IF (RESET)     THEN Idle       "Reset, stop reading.
    ELSE                     HDRdSt     "Want to send read signal to HD


STATE HDRdSt:			" Sends read signal to hard drive

    " Turn off all chip selects except IDE to get info from hard drive
    DSPCS = 1;                  " Disable chip select to display
    POTCS = 1;                  " Disable chip select to digital potentiometer
    DATAE = 1;                  " Disable data latch from display
    IDEE  = 0;                  " IDE Decoder passes low byte through while enabled
    IDEE2 = 1;			" IDE Decoder stores high byte while disabled
    IDECS = 0;                  " Enable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = 1;                    " Want to send read signal to hard drive.
    DA2 = 0;                    " DA2 = 0 for read
    DA1 = 0;                    " DA1 = 0 for read
    DA0 = 0;			" DA0 = 0 for read
    DIR = 0;
    SCLK = 0;
    SAB = 0;
    
    SRDY = 0;                   " Not ready when reading from HD
    
         IF (RESET)     THEN Idle       "Reset, stop reading.
    ELSE                     HDLatchRd  "IDE only needs one state to latch data


STATE HDLatchRd:		" Latches the high byte of data

    " Turn off all chip selects except IDE to get info from hard drive
    DSPCS = 1;                  " Disable chip select to display
    POTCS = 1;                  " Disable chip select to digital potentiometer
    DATAE = 1;                  " Disable data latch from display
    IDEE  = 0;                  " IDE Decoder passes low byte through while enabled
    IDEE2 = 1;			" IDE Decoder stores high byte while disabled
    IDECS = 0;                  " Enable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = 1;                    " Want to send read signal to hard drive.
    DA2 = 0;                    " DA2 = 0 for read
    DA1 = 0;                    " DA1 = 0 for read
    DA0 = 0;			" DA0 = 0 for read
    DIR = 0;
    SCLK = 1;
    SAB = 0;
    
    SRDY = 0;                   " Not ready when reading from HD
    
         IF (RESET)     THEN Idle       "Reset, stop reading.
    ELSE                     HDStopRd   "IDE only needs one state to latch data


STATE HDStopRd:	         	" Stops read signal now that data is latched

    " Turn off all chip selects except IDE to get info from hard drive
    DSPCS = 1;                  " Disable chip select to display
    POTCS = 1;                  " Disable chip select to digital potentiometer
    DATAE = 1;                  " Disable data latch from display
    IDEE  = 0;                  " IDE Decoder passes low byte through while enabled
    IDEE2 = 1;			" IDE Decoder stores high byte while disabled
    IDECS = 0;                  " Enable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = 0;                    " Want to send read signal to hard drive.
    DA2 = 0;                    " DA2 = 0 for read
    DA1 = 0;                    " DA1 = 0 for read
    DA0 = 0;			" DA0 = 0 for read
    DIR = 0;
    SCLK = 0;
    SAB = 0;
    
    SRDY = 0;

         IF (RESET) THEN Idle     " Reset system and state machine
    ELSE                 HDWaitSt " Wait for data hold time


STATE HDWaitSt:			" Waits to satisfy the data hold time requirement

    " Turn off all chip selects except IDE to get info from hard drive
    DSPCS = 1;                  " Disable chip select to display
    POTCS = 1;                  " Disable chip select to digital potentiometer
    DATAE = 1;                  " Disable data latch from display
    IDEE  = 0;                  " IDE Decoder passes low byte through while enabled
    IDEE2 = 1;			" IDE Decoder stores high byte while disabled
    IDECS = 0;                  " Enable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = 0;                    " Want to send read signal to hard drive.
    DA2 = 0;                    " DA2 = 0 for read
    DA1 = 0;                    " DA1 = 0 for read
    DA0 = 0;			" DA0 = 0 for read
    DIR = 0;
    SCLK = 0;
    SAB = 0;
    
    SRDY = 1;

         IF (RESET)       THEN Idle      "Reset, stop reading.
    ELSE IF (MCS0 & AD0)  THEN IDERdHigh "Want to read odd address now
    ELSE IF (MCS0 & !AD0) THEN HDWaitSt  "Still reading low byte with even address
    ELSE		       Idle      "Nothing to do


STATE IDERdHigh:		" Read high byte from latch

    " Turn off all chip selects except IDE latches
    DSPCS = 1;                  " Disable chip select to display
    POTCS = 1;                  " Disable chip select to digital potentiometer
    DATAE = 1;                  " Disable data latch from display
    IDEE  = 1;                  " Don't want low byte from decoder
    IDEE2 = 0;			" Read high byte from decoder
    IDECS = 1;                  " Disable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = 0;                    " Want to send read signal to hard drive.
    DA2 = 0;                    " IDE DA2 not used
    DA1 = 1;                    " Used to read from IDE latch
    DA0 = 0;			" IDE DA0 not used
    DIR = 0;
    SCLK = 0;
    SAB = 1;
    
    SRDY = 0;                   " Not ready when reading from HD
    
         IF (RESET)     	THEN Idle       "Reset, stop reading.
    ELSE IF (MCS0 & AD0) 	THEN IDERdHigh  "Continue reading
    ELSE                     	     Idle       "Nothing to do




" Following states for digital potentiometer

STATE DigPotSt:			" Start digital potentiometer increment/decrement

    " Turn off all chip selects except digital pot
    DSPCS = 1;                  " Disable chip select to display
    POTCS = 1;                  " Don't enable yet.  Want to establish baseline
    DATAE = 1;                  " Disable data latch from display
    IDEE  = 1;                  " Disable IDE decoder
    IDEE2 = 1;			" Disable IDE decoder
    IDECS = 1;                  " Disable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = 0;                    " Want to send read signal to hard drive.
   "DA2 =                         IDE DA2 used to inc/dec. Inc starts low, dec starts high
    DA1 = 0;                    " IDE DA1 not used
    DA0 = 0;			" IDE DA0 not used
    
    SRDY = 0;                   " Not ready when updating brightness
    
         IF (RESET)     	THEN Idle 	WITH DA2 = 0 "Reset, stop incrementing/decrementing
    ELSE IF (PCS1 & AD0) 	THEN DigPotEna  WITH DA2 = 0 "Want to increment
    ELSE IF (PCS1 & !AD0)	THEN DigPotEna  WITH DA2 = 1 "Want to decrement
    ELSE                     	     Idle 	WITH DA2 = 0 "Nothing to do


STATE DigPotEna:		" Now that steadystate has been defined, can enable potentiometer CS

    " Turn off all chip selects except digital pot
    DSPCS = 1;                  " Disable chip select to display
    POTCS = 0;                  " Don't enable yet.  Want to establish baseline
    DATAE = 1;                  " Disable data latch from display
    IDEE  = 1;                  " Disable IDE decoder
    IDEE2 = 1;			" Disable IDE decoder
    IDECS = 1;                  " Disable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = 0;                    " Want to send read signal to hard drive.
   "DA2 =                         IDE DA2 used to inc/dec. Inc starts low, dec starts high
    DA1 = 0;                    " IDE DA1 not used
    DA0 = 0;			" IDE DA0 not used
    
    SRDY = 0;                   " Not ready when updating brightness
    
         IF (RESET)     	THEN Idle 	WITH DA2 = 0 "Reset, stop incrementing/decrementing
    ELSE IF (PCS1 & AD0) 	THEN DigPotUp   WITH DA2 = 0 "Want to increment
    ELSE IF (PCS1 & !AD0)	THEN DigPotDown WITH DA2 = 1 "Want to decrement
    ELSE                     	     Idle 	WITH DA2 = 0 "Nothing to do



STATE DigPotUp:  		" Pulse a 1

    " Turn off all chip selects except digital pot
    DSPCS = 1;                  " Disable chip select to display
    POTCS = 0;                  " Enable digital potentiometer
    DATAE = 1;                  " Disable data latch from display
    IDEE  = 1;                  " Disable IDE decoder
    IDEE2 = 1;			" Disable IDE decoder
    IDECS = 1;                  " Disable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = 0;                    " Want to send read signal to hard drive.
    DA2 = 1;                    " IDE DA2 used to pulse 1 and increment
    DA1 = 0;                    " IDE DA1 not used
    DA0 = 0;			" IDE DA0 not used
    
    SRDY = 0;                   " Not ready when updating brightness

	 IF (RESET)		THEN Idle          " Reset, start over
    ELSE 			     DigPotEna;	   " Continue incrementing/decrementing


STATE DigPotDown:		" Pulse a 0

    " Turn off all chip selects except digital pot
    DSPCS = 1;                  " Disable chip select to display
    POTCS = 0;                  " Enable digital potentiometer
    DATAE = 1;                  " Disable data latch from display
    IDEE  = 1;                  " Disable IDE decoder
    IDEE2 = 1;			" Disable IDE decoder
    IDECS = 1;                  " Disable chip select CS0 to IDE
    IDECS1= 1;			" Disable chip select CS1 to IDE
    
    ORD = 0;                    " Want to send read signal to hard drive.
    DA2 = 0;                    " IDE DA2 used to pulse 1 and increment
    DA1 = 0;                    " IDE DA1 not used
    DA0 = 0;			" IDE DA0 not used
    
    SRDY = 0;                   " Not ready when updating brightness

	 IF (RESET)		THEN Idle          " Reset, start over
    ELSE 			     DigPotEna;	   " Continue incrementing/decrementing



TEST_VECTORS

( [ Clock, RESET, AD0, !PCS1, !MCS0, !PCS5, !RD, !WR ] -> [ SRDY, ORD, DSPCS, DATAE, POTCS, IDECS, IDEE, IDEE2, SCLK, SAB, DA0, DA1, DA2, St0, St1, St2, St3, St4, St5 ] )

" Show reset works
  [   .C.,     0,   0,     0,     1,     1,   0,   0 ] -> [    0, .X.,   .X.,   .X.,   .X.,   .X.,  .X.,   .X.,  .X., .X., .X., .X., .X.,   0,   0,   0,   1,   0,   0 ];
  [   .C.,     1,   0,     0,     0,     0,   0,   0 ] -> [    1, .X.,   .X.,   .X.,   .X.,   .X.,  .X.,   .X.,  .X., .X., .X., .X., .X.,   0,   0,   0,   0,   0,   0 ]; " Reset
  [   .C.,     1,   0,     0,     0,     0,   0,   0 ] -> [    1, .X.,   .X.,   .X.,   .X.,   .X.,  .X.,   .X.,  .X., .X., .X., .X., .X.,   0,   0,   0,   0,   0,   0 ];
  [   .C.,     0,   0,     1,     1,     0,   1,   1 ] -> [    0, .X.,   .X.,   .X.,   .X.,   .X.,  .X.,   .X.,  .X., .X., .X., .X., .X.,   0,   0,   0,   0,   0,   0 ]; " PCS but no RD or WR
  [   .C.,     0,   0,     1,     1,     1,   1,   0 ] -> [    1, .X.,   .X.,   .X.,   .X.,   .X.,  .X.,   .X.,  .X., .X., .X., .X., .X.,   0,   0,   0,   0,   0,   0 ]; " No PCS but WR

" IDE Read low byte (even address)
  [   .C.,     1,   0,     0,     0,     0,   0,   0 ] -> [    1, .X.,   .X.,   .X.,   .X.,   .X.,  .X.,   .X.,    0,   0, .X., .X., .X.,   0,   0,   0,   0,   0,   0 ]; " Reset
  [   .C.,     0,   0,     1,     0,     1,   0,   1 ] -> [    0,   0,   .X.,   .X.,   .X.,     1,    1,     0,    0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0 ]; " Start reading IDE low byte
  [   .C.,     0,   0,     1,     0,     1,   0,   1 ] -> [    0,   1,   .X.,   .X.,   .X.,     1,    1,     0,    0,   0,   0,   0,   0,   0,   1,   0,   0,   1,   0 ]; " Read signal strobes
  [   .C.,     0,   0,     1,     0,     1,   0,   1 ] -> [    0,   1,   .X.,   .X.,   .X.,     1,    1,     0,    1,   0,   0,   0,   0,   0,   1,   0,   0,   1,   0 ]; " Latch with SCLK
  [   .C.,     0,   0,     1,     0,     1,   0,   1 ] -> [    0,   0,   .X.,   .X.,   .X.,     1,    1,     0,    0,   0,   0,   0,   0,   0,   1,   0,   1,   1,   0 ]; " Read signal ceases
  [   .C.,     0,   0,     1,     0,     1,   0,   1 ] -> [    1,   0,   .X.,   .X.,   .X.,     1,    1,     0,    0,   0,   0,   0,   0,   0,   0,   0,   1,   1,   0 ]; " Wait state
  [   .C.,     0,   0,     1,     0,     1,   0,   1 ] -> [    1,   0,   .X.,   .X.,   .X.,     1,    1,     0,    0,   0,   0,   0,   0,   0,   0,   0,   1,   1,   0 ]; " Nothing should change
  [   .C.,     0,   1,     1,     0,     1,   0,   1 ] -> [    0,   0,   .X.,   .X.,   .X.,     0,    0,     1,    0,   0,   0,   1,   0,   0,   0,   0,   1,   0,   0 ]; " Now want to read high byte

" IDE Read high byte (odd address)
  [   .C.,     0,   1,     1,     0,     1,   0,   1 ] -> [    0,   0,   .X.,   .X.,   .X.,     0,    0,     1,    0,   1,   0,   1,   0,   0,   0,   0,   0,   1,   0 ]; " Just enable latch
  [   .C.,     0,   1,     1,     0,     1,   0,   1 ] -> [    0,   0,   .X.,   .X.,   .X.,     0,    0,     1,    0,   1,   0,   1,   0,   0,   0,   0,   0,   1,   0 ]; " Nothing should change
  [   .C.,     0,   0,     1,     1,     1,   0,   1 ] -> [    1, .X.,   .X.,   .X.,   .X.,   .X.,  .X.,   .X.,    0,   1, .X., .X., .X.,   0,   0,   0,   0,   0,   0 ]; " Inactivate chip select

" Display read
  [   .C.,     0,   0,     1,     1,     0,   0,   1 ] -> [    0,   1,     1,     1,   .X.,   .X.,  .X.,   .X.,  .X., .X.,   0, .X.,   0,   0,   0,   0,   0,   0,   1 ]; " Enters state machine
  [   .C.,     0,   0,     1,     1,     0,   0,   1 ] -> [    0,   1,     1,     1,   .X.,   .X.,  .X.,   .X.,  .X., .X.,   0, .X.,   0,   1,   0,   0,   0,   0,   1 ]; " Noise does not affect it
  [   .C.,     0,   0,     0,     1,     0,   0,   1 ] -> [    0,   1,     1,     1,   .X.,   .X.,  .X.,   .X.,  .X., .X.,   0, .X.,   0,   1,   1,   0,   0,   0,   1 ]; "    Other PCS active
  [   .C.,     0,   0,     1,     0,     0,   0,   1 ] -> [    0,   1,     1,     1,   .X.,   .X.,  .X.,   .X.,  .X., .X.,   0, .X.,   0,   0,   1,   0,   0,   0,   1 ]; "    Other PCS active
  [   .C.,     0,   0,     1,     1,     1,   0,   1 ] -> [    0,   1,     1,     1,   .X.,   .X.,  .X.,   .X.,  .X., .X.,   0, .X.,   0,   0,   1,   1,   0,   0,   1 ]; "    Disp PCS inactive
  [   .C.,     0,   0,     1,     1,     0,   0,   0 ] -> [    0,   1,     1,     1,   .X.,   .X.,  .X.,   .X.,  .X., .X.,   0, .X.,   0,   0,   0,   1,   0,   0,   1 ]; "    WR inactive
  [   .C.,     0,   0,     1,     1,     0,   1,   1 ] -> [    0,   1,     1,     1,   .X.,   .X.,  .X.,   .X.,  .X., .X.,   0, .X.,   0,   1,   0,   1,   0,   0,   1 ]; "    RD active
  [   .C.,     0,   0,     1,     1,     0,   0,   1 ] -> [    0,   1,     1,     0,   .X.,   .X.,  .X.,   .X.,  .X., .X.,   0, .X.,   0,   1,   1,   1,   0,   0,   1 ];
  [   .C.,     0,   0,     1,     1,     0,   0,   1 ] -> [    1,   1,     0,     0,   .X.,   .X.,  .X.,   .X.,  .X., .X.,   0, .X.,   0,   1,   1,   1,   0,   0,   1 ];
  [   .C.,     1,   0,     1,     1,     0,   0,   1 ] -> [    1,   0,     0,     0,   .X.,   .X.,  .X.,   .X.,  .X., .X., .X., .X.,   0,   0,   0,   0,   0,   0,   0 ]; " Reset

" Display write
  [   .C.,     0,   0,     1,     1,     0,   1,   0 ] -> [    0,   0,     1,     1,   .X.,   .X.,  .X.,   .X.,  .X., .X.,   1, .X.,   0,   0,   0,   0,   0,   0,   1 ]; " Enters state machine
  [   .C.,     0,   0,     1,     1,     0,   1,   0 ] -> [    0,   0,     1,     1,   .X.,   .X.,  .X.,   .X.,  .X., .X.,   1, .X.,   0,   1,   0,   0,   0,   0,   1 ]; " Noise does not affect it
  [   .C.,     0,   0,     0,     1,     0,   1,   0 ] -> [    0,   0,     1,     1,   .X.,   .X.,  .X.,   .X.,  .X., .X.,   1, .X.,   0,   1,   1,   0,   0,   0,   1 ]; "    Other PCS active
  [   .C.,     0,   0,     1,     0,     0,   1,   0 ] -> [    0,   0,     1,     1,   .X.,   .X.,  .X.,   .X.,  .X., .X.,   1, .X.,   0,   0,   1,   0,   0,   0,   1 ]; "    Other PCS active
  [   .C.,     0,   0,     1,     1,     1,   1,   0 ] -> [    0,   0,     1,     1,   .X.,   .X.,  .X.,   .X.,  .X., .X.,   1, .X.,   0,   0,   1,   1,   0,   0,   1 ]; "    Disp PCS inactive
  [   .C.,     0,   0,     1,     1,     0,   1,   1 ] -> [    0,   0,     1,     1,   .X.,   .X.,  .X.,   .X.,  .X., .X.,   1, .X.,   0,   0,   0,   1,   0,   0,   1 ]; "    RD inactive
  [   .C.,     0,   0,     1,     1,     0,   0,   0 ] -> [    0,   0,     1,     1,   .X.,   .X.,  .X.,   .X.,  .X., .X.,   1, .X.,   0,   1,   0,   1,   0,   0,   1 ]; "    WR active
  [   .C.,     0,   0,     1,     1,     0,   1,   0 ] -> [    0,   0,     1,     0,   .X.,   .X.,  .X.,   .X.,  .X., .X.,   1, .X.,   0,   1,   1,   1,   0,   0,   1 ];
  [   .C.,     0,   0,     1,     1,     0,   1,   0 ] -> [    1,   0,     0,     0,   .X.,   .X.,  .X.,   .X.,  .X., .X.,   1, .X.,   0,   1,   1,   1,   0,   0,   1 ];
  [   .C.,     1,   0,     1,     1,     0,   1,   0 ] -> [    1,   0,     0,     0,   .X.,   .X.,  .X.,   .X.,  .X., .X., .X., .X.,   0,   0,   0,   0,   0,   0,   0 ]; " Reset

" Increment digital pot
  [   .C.,     0,   1,     0,     1,     1,   0,   1 ] -> [    0, .X.,   .X.,   .X.,     0,   .X.,  .X.,   .X.,  .X., .X., .X., .X.,   0,   0,   0,   1,   0,   0,   0 ]; " Start increment
  [   .C.,     0,   1,     0,     1,     1,   0,   1 ] -> [    0, .X.,   .X.,   .X.,     1,   .X.,  .X.,   .X.,  .X., .X., .X., .X.,   0,   0,   0,   1,   1,   0,   0 ]; " Enable digital pot
  [   .C.,     0,   1,     0,     1,     1,   0,   1 ] -> [    0, .X.,   .X.,   .X.,     1,   .X.,  .X.,   .X.,  .X., .X., .X., .X.,   1,   0,   1,   1,   1,   0,   0 ]; " Pulse upward
  [   .C.,     0,   1,     0,     1,     1,   0,   1 ] -> [    0, .X.,   .X.,   .X.,     1,   .X.,  .X.,   .X.,  .X., .X., .X., .X.,   0,   0,   0,   1,   1,   0,   0 ]; " Back to level (0)
  [   .C.,     0,   1,     0,     1,     1,   1,   0 ] -> [    0, .X.,   .X.,   .X.,     1,   .X.,  .X.,   .X.,  .X., .X., .X., .X.,   1,   0,   1,   1,   1,   0,   0 ]; " Pulse upward. Resilient to RD/WR
  [   .C.,     0,   1,     0,     1,     1,   0,   1 ] -> [    0, .X.,   .X.,   .X.,     1,   .X.,  .X.,   .X.,  .X., .X., .X., .X.,   0,   0,   0,   1,   1,   0,   0 ]; " Back to level (0)
  [   .C.,     1,   1,     0,     1,     1,   0,   1 ] -> [    0, .X.,   .X.,   .X.,     0,   .X.,  .X.,   .X.,  .X., .X., .X., .X.,   0,   0,   0,   0,   0,   0,   0 ]; " Reset

" Decrement digital pot
  [   .C.,     0,   0,     0,     1,     1,   0,   1 ] -> [    0, .X.,   .X.,   .X.,     0,   .X.,  .X.,   .X.,  .X., .X., .X., .X.,   1,   0,   0,   1,   0,   0,   0 ]; " Start increment
  [   .C.,     0,   0,     0,     1,     1,   0,   1 ] -> [    0, .X.,   .X.,   .X.,     1,   .X.,  .X.,   .X.,  .X., .X., .X., .X.,   1,   0,   0,   1,   1,   0,   0 ]; " Enable digital pot
  [   .C.,     0,   0,     0,     1,     1,   0,   1 ] -> [    0, .X.,   .X.,   .X.,     1,   .X.,  .X.,   .X.,  .X., .X., .X., .X.,   0,   1,   0,   1,   1,   0,   0 ]; " Pulse upward
  [   .C.,     0,   0,     0,     1,     1,   0,   1 ] -> [    0, .X.,   .X.,   .X.,     1,   .X.,  .X.,   .X.,  .X., .X., .X., .X.,   1,   0,   0,   1,   1,   0,   0 ]; " Back to level (0)
  [   .C.,     0,   0,     0,     1,     1,   1,   0 ] -> [    0, .X.,   .X.,   .X.,     1,   .X.,  .X.,   .X.,  .X., .X., .X., .X.,   0,   1,   0,   1,   1,   0,   0 ]; " Pulse upward. Resilient to RD/WR
  [   .C.,     0,   0,     0,     1,     1,   0,   1 ] -> [    0, .X.,   .X.,   .X.,     1,   .X.,  .X.,   .X.,  .X., .X., .X., .X.,   1,   0,   0,   1,   1,   0,   0 ]; " Back to level (0)
  [   .C.,     1,   0,     0,     1,     1,   0,   1 ] -> [    0, .X.,   .X.,   .X.,     0,   .X.,  .X.,   .X.,  .X., .X., .X., .X.,   0,   0,   0,   0,   0,   0,   0 ]; " Reset

END

