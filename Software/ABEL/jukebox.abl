MODULE Jukebox

TITLE 'Jukebox CPLD'


" Jukebox Interface  DEVICE  'ISPLSI1016'


" Description:  Interfaces the LCD Display, IDE and digital potentiometer.
"               It assumes the CPU is running on a 24 MHz clock.  CPU assumed
"               to be 80C188XL.
"
"               Display: This interfaces the NHD-0420DZ-FSW-FBW display, which
"               is 4 lines by 20 characters in size.  To write to the display,
"               there is a data latch whose enable and direction are controlled
"               by the CPLD.  The CPLD uses the WR and PCS signals from the CPU
"               to execute display writing.  To read from the display, the RD
"               and PCS are used and the CPLD reverses the direction on the
"               data latch.
"
"               IDE: This only reads from IDE.  The IDE sends 16 bits of data
"               to a 74FCT16646, which latches it all.  The CPLD controls when
"               the high and low byte of this data are read by dictating the
"               enable and direction of dataflow on the 74FCT16646.
"
"               Digital Potentiometer: This increases and decreases the voltage
"               at the wiper terminal using the data input from the CPU.  The
"               data is the low bit.  1 increments and 0 decrements.  This
"               machine works by always sending a 1 and a 0.  Which comes first
"               is determined by the operation (inc or dec).
"

" Revision History:
" 02/12/16      Created with functionality for 4x20 Display, IDE interface and
"                   digital potentiometer.
" 03/06/16      Added functionality for DRAM refresh, read and write



" Pins

"GND   pin   1;                  supply  power ground
"      pin   2;                  input   unused (IN3)
ALE    pin   3;                 "input   Address latch enable (Active low from 80C188)
DTR    pin   4;                 "input   DT/R signal (from 80C188)
A0     pin   5;                 "input   LSB from address bus
CLKBA  pin   6   ISTYPE 'com';  "output  IDE decoder 2CLKBA signal
!OE1   pin   7   ISTYPE 'com';  "output  IDE decoder 1OE signal
DIR1   pin   8   ISTYPE 'com';  "output  IDE decoder 1DIR signal
SRDY   pin   9   ISTYPE 'com';  "output  synchronous ready to 80C188
!POT   pin   10  ISTYPE 'com';  "output  Pot chip select
Clock  pin   11;                "input   24 MHz clock
"VCC   pin   12                  supply  power Vcc
"ISPEN pin   13                  input   Tied high
"      pin   14                  unused  (IN0/SDI)
DIOR   pin   15  ISTYPE 'com';  "output  DIOR signal to IDE
!OE2   pin   16  ISTYPE 'com';  "output  IDE decoder 2OE signal
!CS0   pin   17  ISTYPE 'com';  "output  IDE CS0 signal
MUX    pin   18  ISTYPE 'reg';  "output  MUX selector signal
!CAS   pin   19  ISTYPE 'reg';  "output  DRAM CAS signal
!DRAM  pin   20  ISTYPE 'reg';  "output  DRAM write enable signal
DIOW   pin   21  ISTYPE 'com';  "output  DIOW signal to IDE
!RAS   pin   22  ISTYPE 'reg';  "output  DRAM RAS signal
"GND   pin   23                  supply  power ground
"      pin   24                  unused  (IN1/SD0)
"!XCS   pin   25  ISTYPE 'com';  output  XCS signal to MP3 decoder
"!XDCS  pin   26  ISTYPE 'com';  output  XDCS signal to MP3 decoder
!DISPE pin   27  ISTYPE 'com';  "output  Enable signal to display
CLKUD  pin   28  ISTYPE 'com';  "output  Serial clock to MP3 decoder, U/D to digital pot
!DATA  pin   29  ISTYPE 'com';  "output  Data enable to display buffer
DDIR   pin   30  ISTYPE 'com';  "output  Data direction for display
DRW    pin   31  ISTYPE 'com';  "output  R/W signal to display
!DISP  pin   32  ISTYPE 'com';  "output  Chip select to display
"      pin   33                  unused  (Y2/SCLK)
"VCC   pin   34                  supply  power Vcc
"RESET pin   35;                 input   Reset (active high from 80C188)
MCS1   pin   37;                "input   DRAM Refresh (Active low from 80C188)
MCS2   pin   38;                "input   DRAM access (Active low from 80C188)
MCS0   pin   39;                "input   IDE chip select (Active low from 80C188)
PCS6   pin   40;                "input   Display brightness (Active low from 80C188)
RESET  pin   41;                "input   Reset from 80C188
PCS5   pin   42;                "input   Display (Active low from 80C188)
PCS3   pin   43;                "input   MP3 SCI (Active low from 80C188)
PCS2   pin   44;                "input   MP3 SDI (Active low from 80C188)


" State bits for DRAM state machine
DR0    pin       ISTYPE 'reg';  "output  state bit 0
DR1    pin       ISTYPE 'reg';  "output  state bit 1

" Temporary SRDY so only one state machine writes to SRDY
tSRDY  pin       ISTYPE 'reg';  "output  SRDY

" General registers
RDWR   pin       ISTYPE 'reg';  "keeps track of whether we are reading (0) or writing (1)



"################################################
"#
"# Display, IDE, Digital Pot, MP3 State bits
"#
"#

St0    pin       ISTYPE 'reg';  "output  state bit 0
St1    pin       ISTYPE 'reg';  "output  state bit 1
St2    pin       ISTYPE 'reg';  "output  state bit 2
St3    pin       ISTYPE 'reg';  "output  state bit 3
St4    pin       ISTYPE 'reg';  "output  state bit 4
St5    pin       ISTYPE 'reg';  "output  state bit 5



" Display, IDE, Digital Pot, MP3

StateBits  =  [ St5, St4, St3, St2, St1, St0 ]; " state bits
                                                " state assignments
" Start state
Idle       =  [   0,   0,   0,   0,   0,   0 ]; " idle state (waiting for a cycle to start)

" Display states
DispSt     =  [   1,   0,   0,   0,   0,   0 ]; " start of display access cycle
DispWt1    =  [   1,   0,   0,   0,   0,   1 ]; " wait state 1 (so E cycle is 460 ns long)
DispWt2    =  [   1,   0,   0,   0,   1,   1 ]; " wait state 2
DispWt3    =  [   1,   0,   0,   0,   1,   0 ]; " wait state 3
DispWt4    =  [   1,   0,   0,   1,   1,   0 ]; " wait state 4
DispWt5    =  [   1,   0,   0,   1,   0,   0 ]; " wait state 5
DispWt6    =  [   1,   0,   0,   1,   0,   1 ]; " wait state 6
DispDisE   =  [   1,   0,   0,   1,   1,   1 ]; " begins data hold period
DispStop   =  [   1,   0,   1,   1,   1,   1 ]; " stops write cycle, CPU responsible for 1200 ns wait

" IDE read states
IDERdLow   =  [   0,   1,   0,   0,   0,   0 ]; " starts reading low byte from IDE/hard drive
HDRdSt     =  [   0,   1,   0,   0,   0,   1 ]; " sets read signal high to start data read
HDLatchRd  =  [   0,   1,   1,   0,   0,   1 ]; " latches the high byte of data onto IDE decoder
HDStopRd   =  [   0,   1,   1,   0,   0,   0 ]; " stops read signal to wrap up data transfer from HD to IDE decoder
HDWaitSt   =  [   0,   1,   1,   1,   0,   0 ]; " waits so the data hold is observed
IDERdHigh  =  [   0,   0,   1,   0,   0,   0 ]; " starts reading high byte from IDE decoder

" Digital potentiometer states
DigPotSt   =  [   0,   0,   0,   1,   0,   0 ]; " creates standard that tells pot if inc or dec operation
DigPotEna  =  [   0,   0,   1,   1,   0,   0 ]; " enables digital potentiometer/waits to do next pulse
DigPotUp   =  [   0,   0,   1,   1,   1,   0 ]; " pulses a 1 to the potentiometer data pin
DigPotDown =  [   0,   0,   1,   1,   0,   1 ]; " pulses a 0 to the potentiometer data pin


"################################################
"#
"# DRAM State bits
"#
"#

" No-output encoding:
DRAM_bits      =  [ DR0, DR1, MUX, CAS, RAS, DRAM ]; " state bits for DRAM refresh state machine

" Start state
DRAM_Idle      =  [   0,   0,   0,   0,   0,    0 ]; " idle state (waiting for a cycle to start)

" Refresh state machine
DRAMRfshStart  =  [   0,   0,   0,   1,   0,    0 ]; " CAS-before-RAS; start CAS
DRAMRfshFinish =  [   0,   0,   0,   1,   1,    0 ]; " RAS part of refresh

" Read state machine
DRAMReadStart  =  [   0,   1,   1,   0,   1,    0 ]; " Start read with MUX for row address
DRAMReadRow    =  [   0,   1,   0,   0,   1,    0 ]; " Read row, change MUX for col address
DRAMReadCol    =  [   0,   1,   0,   1,   1,    0 ]; " Read col
DRAMReadWait   =  [   0,   1,   0,   0,   0,    0 ]; " Wait state after reading

" Write state machine
DRAMWriteStart =  [   0,   0,   1,   0,   1,    1 ]; " Start write with MUX for row address
DRAMWriteRow   =  [   0,   0,   0,   0,   1,    1 ]; " Get row addr, change MUX for col addr
DRAMWriteCol   =  [   0,   0,   0,   1,   1,    1 ]; " Get col addr
DRAMWrite      =  [   1,   0,   0,   1,   1,    0 ]; " Clear WE to perform actual write




EQUATIONS


" Output enables - enable the used outputs (registered outputs enabled by OE pin)
CLKBA.OE = 1;
OE1.OE   = 1;
DIR1.OE  = 1;
SRDY.OE  = 1;
POT.OE   = 1;
DIOR.OE  = 1;
OE2.OE   = 1;
CS0.OE   = 1;
DIOW.OE  = 1;
"XCS.OE   = 1;
"XDCS.OE  = 1;
DISPE.OE = 1;
CLKUD.OE = 1;
DATA.OE  = 1;
DDIR.OE  = 1;
DRW.OE   = 1;
DISP.OE  = 1;


" clocks for the registered outputs
DRAM_bits.CLK  =  Clock;        " use the global clock pin
StateBits.CLK  =  Clock;        " use the global clock pin
tSRDY.CLK      =  Clock;        " use the global clock pin
RDWR.CLK       =  Clock;        " use the global clock pin







"#############################################################################
"#
"# Everything Else State Machine:
"#      Display
"#      IDE
"#      Digital Pot
"#      MP3
"#
"#
"#
"#


STATE_DIAGRAM  StateBits        " a Mealy state machine


STATE  Idle:                    " Wait idly with nothing enabled

    " Turn off all chip selects
    DISP  = 0;                  " Disable chip select to display
    DISPE = 0;			" Disable display (irrelevant without DISP)
    DRW   = 0;			" Display read/write irrelevant without DISP
    DDIR  = 0; 			" Default direction toward display
    POT   = 0;                  " Disable chip select to digital potentiometer
    CLKUD = 0;			" Value irrelevant without POT or XCS/XDCS
    DATA  = 0;                  " Disable latching data
    CS0   = 0;                  " Disable IDE chip select
    OE1   = 0;			" Disable IDE output 1
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 0;			" Value irrelevant with CS0 inactive
    DIR1  = 0;			" IDE direction irrelevant without CS0
    DIOW  = 0; 			" IDE write inactive (irrelevant without CS0)
    DIOR  = 0;			" IDE read inactive (irrelevant without CS0)
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 1;                  " SRDY always 'ready' in this state

         IF (RESET)         THEN Idle      WITH RDWR = 0  " On reset do nothing
    ELSE IF (PCS5 & DTR)    THEN DispSt    WITH RDWR = 0  " DA0 puts latch direction toward display
    ELSE IF (PCS5 & !DTR)   THEN DispSt    WITH RDWR = 1  " DA0 puts latch direction toward CPU
    ELSE IF (MCS0 & A0)     THEN IDERdHigh WITH RDWR = 0  " Odd address, read high byte
    ELSE IF (MCS0 & !A0)    THEN IDERdLow  WITH RDWR = 0  " Even address, read low byte
    ELSE IF (PCS6)          THEN DigPotSt  WITH RDWR = 0  " Increment or decrement digital pot
    ELSE                         Idle      WITH RDWR = 0; " otherwise just stay here



" Following states correspond to writing to display

STATE DispSt:                   " Begin display write cycle

    " Display
    DISP  = 1;                  " Enable chip select to display
    DISPE = 1;			" Enable display data
    DRW   = !RDWR;		" Display read/write
    DDIR  = !RDWR;		" Direction toward data bus
    POT   = 0;                  " Disable chip select to digital potentiometer
    CLKUD = 0;			" Value irrelevant without POT or XCS/XDCS
    DATA  = 0;                  " Disable latching data
    CS0   = 0;                  " Disable IDE chip select
    OE1   = 0;			" Disable IDE output 1
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 0;			" Value irrelevant with CS0 inactive
    DIR1  = 0;			" IDE direction irrelevant without CS0
    DIOW  = 0; 			" IDE write inactive (irrelevant without CS0)
    DIOR  = 0;			" IDE read inactive (irrelevant without CS0)
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 0;                  " SRDY not ready while displaying

         IF (RESET)     THEN Idle       "Reset, stop displaying.
    ELSE                     DispWt1    "Next state enables data latch


STATE DispWt1:                  " Begin waiting while display sets up

    " Display
    DISP  = 1;                  " Enable chip select to display
    DISPE = 1;			" Enable display data
    DRW   = !RDWR;		" Display read/write
    DDIR  = !RDWR;		" Direction toward data bus if reading, display if writing
    POT   = 0;                  " Disable chip select to digital potentiometer
    CLKUD = 0;			" Value irrelevant without POT or XCS/XDCS
    DATA  = 0;                  " Disable latching data
    CS0   = 0;                  " Disable IDE chip select
    OE1   = 0;			" Disable IDE output 1
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 0;			" Value irrelevant with CS0 inactive
    DIR1  = 0;			" IDE direction irrelevant without CS0
    DIOW  = 0; 			" IDE write inactive (irrelevant without CS0)
    DIOR  = 0;			" IDE read inactive (irrelevant without CS0)
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 0;                  " SRDY not ready while displaying

         IF (RESET)     THEN Idle       "Reset, stop displaying.
    ELSE                     DispWt2    "Continue waiting


STATE DispWt2:                  " Continue waiting while display sets up

    " Display
    DISP  = 1;                  " Enable chip select to display
    DISPE = 1;			" Enable display data
    DRW   = !RDWR;		" Display read/write
    DDIR  = !RDWR;		" Direction toward data bus if reading, display if writing
    POT   = 0;                  " Disable chip select to digital potentiometer
    CLKUD = 0;			" Value irrelevant without POT or XCS/XDCS
    DATA  = 0;                  " Disable latching data
    CS0   = 0;                  " Disable IDE chip select
    OE1   = 0;			" Disable IDE output 1
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 0;			" Value irrelevant with CS0 inactive
    DIR1  = 0;			" IDE direction irrelevant without CS0
    DIOW  = 0; 			" IDE write inactive (irrelevant without CS0)
    DIOR  = 0;			" IDE read inactive (irrelevant without CS0)
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 0;                  " SRDY not ready while displaying

         IF (RESET)     THEN Idle       "Reset, stop displaying.
    ELSE                     DispWt3    "Continue waiting


STATE DispWt3:                  " Continue waiting while display sets up

    " Display
    DISP  = 1;                  " Enable chip select to display
    DISPE = 1;			" Enable display data
    DRW   = !RDWR;		" Display read/write
    DDIR  = !RDWR;		" Direction toward data bus if reading, display if writing
    POT   = 0;                  " Disable chip select to digital potentiometer
    CLKUD = 0;			" Value irrelevant without POT or XCS/XDCS
    DATA  = 0;                  " Disable latching data
    CS0   = 0;                  " Disable IDE chip select
    OE1   = 0;			" Disable IDE output 1
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 0;			" Value irrelevant with CS0 inactive
    DIR1  = 0;			" IDE direction irrelevant without CS0
    DIOW  = 0; 			" IDE write inactive (irrelevant without CS0)
    DIOR  = 0;			" IDE read inactive (irrelevant without CS0)
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 0;                  " SRDY not ready while displaying

         IF (RESET)     THEN Idle       "Reset, stop displaying.
    ELSE                     DispWt4    "Continue waiting


STATE DispWt4:                  " Continue waiting while display sets up

    " Display
    DISP  = 1;                  " Enable chip select to display
    DISPE = 1;			" Enable display data
    DRW   = !RDWR;		" Display read/write
    DDIR  = !RDWR;		" Direction toward data bus if reading, display if writing
    POT   = 0;                  " Disable chip select to digital potentiometer
    CLKUD = 0;			" Value irrelevant without POT or XCS/XDCS
    DATA  = 0;                  " Disable latching data
    CS0   = 0;                  " Disable IDE chip select
    OE1   = 0;			" Disable IDE output 1
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 0;			" Value irrelevant with CS0 inactive
    DIR1  = 0;			" IDE direction irrelevant without CS0
    DIOW  = 0; 			" IDE write inactive (irrelevant without CS0)
    DIOR  = 0;			" IDE read inactive (irrelevant without CS0)
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 0;                  " SRDY not ready while displaying

         IF (RESET)     THEN Idle       "Reset, stop displaying.
    ELSE                     DispWt5    "Continue waiting


STATE DispWt5:                  " Continue waiting while display sets up

    " Display
    DISP  = 1;                  " Enable chip select to display
    DISPE = 1;			" Enable display data
    DRW   = !RDWR;		" Display read/write
    DDIR  = !RDWR;		" Direction toward data bus if reading, display if writing
    POT   = 0;                  " Disable chip select to digital potentiometer
    CLKUD = 0;			" Value irrelevant without POT or XCS/XDCS
    DATA  = 0;                  " Disable latching data
    CS0   = 0;                  " Disable IDE chip select
    OE1   = 0;			" Disable IDE output 1
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 0;			" Value irrelevant with CS0 inactive
    DIR1  = 0;			" IDE direction irrelevant without CS0
    DIOW  = 0; 			" IDE write inactive (irrelevant without CS0)
    DIOR  = 0;			" IDE read inactive (irrelevant without CS0)
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 0;                  " SRDY not ready while displaying

         IF (RESET)     THEN Idle       "Reset, stop displaying.
    ELSE                     DispWt6    "Continue waiting


STATE DispWt6:                  " Continue waiting while display sets up

    " Display
    DISP  = 1;                  " Enable chip select to display
    DISPE = 1;			" Enable display data
    DRW   = !RDWR;		" Display read/write
    DDIR  = !RDWR;		" Direction toward data bus if reading, display if writing
    POT   = 0;                  " Disable chip select to digital potentiometer
    CLKUD = 0;			" Value irrelevant without POT or XCS/XDCS
    DATA  = 0;                  " Disable latching data
    CS0   = 0;                  " Disable IDE chip select
    OE1   = 0;			" Disable IDE output 1
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 0;			" Value irrelevant with CS0 inactive
    DIR1  = 0;			" IDE direction irrelevant without CS0
    DIOW  = 0; 			" IDE write inactive (irrelevant without CS0)
    DIOR  = 0;			" IDE read inactive (irrelevant without CS0)
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 0;                  " SRDY not ready while displaying

         IF (RESET)     THEN Idle       "Reset, stop displaying.
    ELSE                     DispDisE   "Disable display to start data hold


STATE DispDisE:                 " Disable display to start data hold

    " Display
    DISP  = 1;                  " Enable chip select to display
    DISPE = 0;			" Disable display (irrelevant without DISP)
    DRW   = !RDWR;		" Display read/write
    DDIR  = !RDWR;		" Direction toward data bus if reading, display if writing
    POT   = 0;                  " Disable chip select to digital potentiometer
    CLKUD = 0;			" Value irrelevant without POT or XCS/XDCS
    DATA  = 0;                  " Disable latching data
    CS0   = 0;                  " Disable IDE chip select
    OE1   = 0;			" Disable IDE output 1
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 0;			" Value irrelevant with CS0 inactive
    DIR1  = 0;			" IDE direction irrelevant without CS0
    DIOW  = 0; 			" IDE write inactive (irrelevant without CS0)
    DIOR  = 0;			" IDE read inactive (irrelevant without CS0)
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 0;                  " SRDY not ready while displaying

         IF (RESET)     THEN Idle       "Reset, stop displaying.
    ELSE                     DispStop   "Done displaying other than enable cycle


STATE DispStop:                 " Stops display cycle.  Enable cycle assumed to be observed by CPU

    " Display
    DISP  = 1;                  " Enable chip select to display
    DISPE = 0;			" Disable display (irrelevant without DISP)
    DRW   = !RDWR;		" Display read/write
    DDIR  = !RDWR;		" Direction toward data bus if reading, display if writing
    POT   = 0;                  " Disable chip select to digital potentiometer
    CLKUD = 0;			" Value irrelevant without POT or XCS/XDCS
    DATA  = 0;                  " Disable latching data
    CS0   = 0;                  " Disable IDE chip select
    OE1   = 0;			" Disable IDE output 1
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 0;			" Value irrelevant with CS0 inactive
    DIR1  = 0;			" IDE direction irrelevant without CS0
    DIOW  = 0; 			" IDE write inactive (irrelevant without CS0)
    DIOR  = 0;			" IDE read inactive (irrelevant without CS0)
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 0;                  " SRDY not ready while displaying

         IF (RESET)             THEN Idle       "Reset, stop displaying.
    ELSE IF (PCS5)              THEN DispStop   "Require PCS rising edge to start cycle
    ELSE                             Idle       "Go back to beginning




" State definitions for IDE operations

STATE IDERdLow:                 " Starts IDE read cycle to read low byte

    " Read low byte from IDE
    DISP  = 0;                  " Disable chip select to display
    DISPE = 0;			" Disable display (irrelevant without DISP)
    DRW   = 0;			" Display read/write irrelevant
    DDIR  = 0;			" Default direction away from data bus.
    POT   = 0;                  " Disable chip select to digital potentiometer
    CLKUD = 0;			" Value irrelevant without POT or XCS/XDCS
    DATA  = 0;                  " Disable latching data
    CS0   = 1;                  " Enable IDE chip select
    OE1   = 1;			" Enable IDE output 1 for reading low byte
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 0;			" Rising edge will latch high byte
    DIR1  = 0;			" IDE direction away from IDE, toward data bus
    DIOW  = 0; 			" IDE write inactive
    DIOR  = 0;			" IDE read inactive for first clock
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 0;                  " SRDY not ready while reading

         IF (RESET)     THEN Idle       "Reset, stop reading.
    ELSE                     HDRdSt     "Want to send read signal to HD


STATE HDRdSt:                   " Sends read signal to hard drive

    " Read low byte from IDE
    DISP  = 0;                  " Disable chip select to display
    DISPE = 0;			" Disable display (irrelevant without DISP)
    DRW   = 0;			" Display read/write irrelevant
    DDIR  = 0;			" Default direction away from data bus.
    POT   = 0;                  " Disable chip select to digital potentiometer
    CLKUD = 0;			" Value irrelevant without POT or XCS/XDCS
    DATA  = 0;                  " Disable latching data
    CS0   = 1;                  " Enable IDE chip select
    OE1   = 1;			" Enable IDE output 1 for reading low byte
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 0;			" Rising edge will latch high byte
    DIR1  = 0;			" IDE direction away from IDE, toward data bus
    DIOW  = 0; 			" IDE write inactive
    DIOR  = 1;			" IDE read active
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 0;                  " SRDY not ready while reading

         IF (RESET)     THEN Idle       "Reset, stop reading.
    ELSE                     HDLatchRd  "IDE only needs one state to latch data


STATE HDLatchRd:                " Latches the high byte of data

    " Read low byte from IDE
    DISP  = 0;                  " Disable chip select to display
    DISPE = 0;			" Disable display (irrelevant without DISP)
    DRW   = 0;			" Display read/write irrelevant
    DDIR  = 0;			" Default direction away from data bus.
    POT   = 0;                  " Disable chip select to digital potentiometer
    CLKUD = 0;			" Value irrelevant without POT or XCS/XDCS
    DATA  = 0;                  " Disable latching data
    CS0   = 1;                  " Enable IDE chip select
    OE1   = 1;			" Enable IDE output 1 for reading low byte
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 1;			" Latch high byte
    DIR1  = 0;			" IDE direction away from IDE, toward data bus
    DIOW  = 0; 			" IDE write inactive
    DIOR  = 1;			" IDE read active
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 0;                  " SRDY not ready while reading

         IF (RESET)     THEN Idle       "Reset, stop reading.
    ELSE                     HDStopRd   "IDE only needs one state to latch data


STATE HDStopRd:                 " Stops read signal now that data is latched

    " Read low byte from IDE
    DISP  = 0;                  " Disable chip select to display
    DISPE = 0;			" Disable display (irrelevant without DISP)
    DRW   = 0;			" Display read/write irrelevant
    DDIR  = 0;			" Default direction away from data bus.
    POT   = 0;                  " Disable chip select to digital potentiometer
    CLKUD = 0;			" Value irrelevant without POT or XCS/XDCS
    DATA  = 0;                  " Disable latching data
    CS0   = 1;                  " Enable IDE chip select
    OE1   = 1;			" Enable IDE output 1 for reading low byte
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 0;			" Rising edge will latch high byte
    DIR1  = 0;			" IDE direction away from IDE, toward data bus
    DIOW  = 0; 			" IDE write inactive
    DIOR  = 0;			" Done with access directly to IDE
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 0;                  " SRDY not ready while reading

         IF (RESET) THEN Idle     " Reset system and state machine
    ELSE                 HDWaitSt " Wait for data hold time


STATE HDWaitSt:                 " Waits to satisfy the data hold time requirement

    " Read low byte from IDE
    DISP  = 0;                  " Disable chip select to display
    DISPE = 0;			" Disable display (irrelevant without DISP)
    DRW   = 0;			" Display read/write irrelevant
    DDIR  = 0;			" Default direction away from data bus.
    POT   = 0;                  " Disable chip select to digital potentiometer
    CLKUD = 0;			" Value irrelevant without POT or XCS/XDCS
    DATA  = 0;                  " Disable latching data
    CS0   = 1;                  " Enable IDE chip select
    OE1   = 1;			" Enable IDE output 1 for reading low byte
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 0;			" Rising edge will latch high byte
    DIR1  = 0;			" IDE direction away from IDE, toward data bus
    DIOW  = 0; 			" IDE write inactive
    DIOR  = 0;			" Done with access directly to IDE
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 1;                  " SRDY ready now that we're done reading

         IF (RESET)       THEN Idle      "Reset, stop reading.
    ELSE IF (MCS0 & A0)   THEN IDERdHigh "Want to read odd address now
    ELSE IF (MCS0 & !A0)  THEN HDWaitSt  "Still reading low byte with even address
    ELSE                       Idle      "Nothing to do


STATE IDERdHigh:                " Read high byte from latch

    " Read high byte from IDE decoder
    DISP  = 0;                  " Disable chip select to display
    DISPE = 0;			" Disable display (irrelevant without DISP)
    DRW   = 0;			" Display read/write irrelevant
    DDIR  = 0;			" Default direction away from data bus.
    POT   = 0;                  " Disable chip select to digital potentiometer
    CLKUD = 0;			" Value irrelevant without POT or XCS/XDCS
    DATA  = 0;                  " Disable latching data
    CS0   = 0;                  " Disable IDE chip select
    OE1   = 0;			" Disable IDE output 1 for reading high byte
    OE2   = 1;			" Enable IDE output 2 for reading high byte
    CLKBA = 0;			" Rising edge will latch high byte
    DIR1  = 0;			" IDE directio irrelevant without OE1
    DIOW  = 0; 			" IDE write inactive
    DIOR  = 0;			" Done with access directly to IDE
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 0;                  " SRDY ready now that we're done reading

         IF (RESET)             THEN Idle       "Reset, stop reading.
    ELSE IF (MCS0 & A0)         THEN IDERdHigh  "Continue reading
    ELSE                             Idle       "Nothing to do




" Following states for digital potentiometer

STATE DigPotSt:                 " Start digital potentiometer increment/decrement

    " Alter digital potentiometer voltage
    DISP  = 0;                  " Disable chip select to display
    DISPE = 0;			" Disable display (irrelevant without DISP)
    DRW   = 0;			" Display read/write irrelevant
    DDIR  = 0;			" Default direction away from data bus.
    POT   = 0;                  " Disable chip select to digital potentiometer
    CLKUD = 0;			" Start low and pulse high
    DATA  = 0;                  " Disable latching data
    CS0   = 0;                  " Disable IDE chip select
    OE1   = 0;			" Disable IDE output 1
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 0;			" Rising edge will latch high byte
    DIR1  = 0;			" IDE directio irrelevant without OE1
    DIOW  = 0; 			" IDE write inactive
    DIOR  = 0;			" Done with access directly to IDE
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 0;                  " SRDY ready now that we're done reading

         IF (RESET)             THEN Idle       WITH CLKUD = 0 "Reset, stop incrementing/decrementing
    ELSE IF (PCS6 & A0)         THEN DigPotEna  WITH CLKUD = 0 "Want to increment
    ELSE IF (PCS6 & !A0)        THEN DigPotEna  WITH CLKUD = 1 "Want to decrement
    ELSE                             Idle       WITH CLKUD = 0 "Nothing to do


STATE DigPotEna:                " Now that steadystate has been defined, can enable potentiometer CS

    " Alter digital potentiometer voltage
    DISP  = 0;                  " Disable chip select to display
    DISPE = 0;			" Disable display (irrelevant without DISP)
    DRW   = 0;			" Display read/write irrelevant
    DDIR  = 0;			" Default direction away from data bus.
    POT   = 1;                  " Enable chip select to digital potentiometer
    "CLKUD = 0;			  Set in IF statement
    DATA  = 0;                  " Disable latching data
    CS0   = 0;                  " Disable IDE chip select
    OE1   = 0;			" Disable IDE output 1
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 0;			" Rising edge will latch high byte
    DIR1  = 0;			" IDE directio irrelevant without OE1
    DIOW  = 0; 			" IDE write inactive
    DIOR  = 0;			" Done with access directly to IDE
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 0;                  " SRDY ready now that we're done reading

         IF (RESET)             THEN Idle       WITH CLKUD = 0 "Reset, stop incrementing/decrementing
    ELSE IF (PCS6 & A0)         THEN DigPotUp   WITH CLKUD = 0 "Want to increment
    ELSE IF (PCS6 & !A0)        THEN DigPotDown WITH CLKUD = 1 "Want to decrement
    ELSE                             Idle       WITH CLKUD = 0 "Nothing to do



STATE DigPotUp:                 " Pulse a 1

    " Alter digital potentiometer voltage
    DISP  = 0;                  " Disable chip select to display
    DISPE = 0;			" Disable display (irrelevant without DISP)
    DRW   = 0;			" Display read/write irrelevant
    DDIR  = 0;			" Default direction away from data bus.
    POT   = 1;                  " Enable chip select to digital potentiometer
    CLKUD = 1;			" Pulse high
    DATA  = 0;                  " Disable latching data
    CS0   = 0;                  " Disable IDE chip select
    OE1   = 0;			" Disable IDE output 1
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 0;			" Rising edge will latch high byte
    DIR1  = 0;			" IDE directio irrelevant without OE1
    DIOW  = 0; 			" IDE write inactive
    DIOR  = 0;			" Done with access directly to IDE
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 0;                  " SRDY ready now that we're done reading

         IF (RESET)             THEN Idle          " Reset, start over
    ELSE                             DigPotEna;    " Continue incrementing/decrementing


STATE DigPotDown:               " Pulse a 0

    " Alter digital potentiometer voltage
    DISP  = 0;                  " Disable chip select to display
    DISPE = 0;			" Disable display (irrelevant without DISP)
    DRW   = 0;			" Display read/write irrelevant
    DDIR  = 0;			" Default direction away from data bus.
    POT   = 1;                  " Enable chip select to digital potentiometer
    CLKUD = 0;			" Pulse low
    DATA  = 0;                  " Disable latching data
    CS0   = 0;                  " Disable IDE chip select
    OE1   = 0;			" Disable IDE output 1
    OE2   = 0;			" Disable IDE output 2
    CLKBA = 0;			" Rising edge will latch high byte
    DIR1  = 0;			" IDE directio irrelevant without OE1
    DIOW  = 0; 			" IDE write inactive
    DIOR  = 0;			" Done with access directly to IDE
    "XCS   = 0;                   Disable MP3 SCI
    "XDCS  = 0;                   Disable MP3 SDI

    tSRDY = 0;                  " SRDY ready now that we're done reading

         IF (RESET)             THEN Idle          " Reset, start over
    ELSE                             DigPotEna;    " Continue incrementing/decrementing






"#############################################################################
"#
"# DRAM State Machine
"#
"#
"#
"#



STATE_DIAGRAM  DRAM_bits        " a Mealy state machine


STATE  DRAM_Idle:               " Wait idly with nothing enabled

    " No-output state encoding.  Must only set SRDY explicitly
    SRDY = 1;                   " SRDY always 'ready' in this state

         IF (RESET)          THEN DRAM_Idle      " On reset do nothing
    ELSE IF (!MCS1)          THEN DRAMRfshStart  " Start refresh cycle
    ELSE IF (!MCS2 & DTR)    THEN DRAMWriteStart " Start writing to DRAM
    ELSE IF (!MCS2 & !DTR)   THEN DRAMReadStart  " Start reading from DRAM
    ELSE                          DRAM_Idle;     " otherwise just stay here


STATE DRAMRfshStart:            " Start refresh cycle

    " No-output state encoding.  Must only set SRDY explicitly
    SRDY = 0;                   " SRDY not ready while refreshing

         IF (RESET)     THEN DRAM_Idle          " On reset, go to start state
    ELSE                     DRAMRfshFinish;    " Finish refresh cycle


STATE DRAMRfshFinish:           " Finish refresh cycle

    " No-output state encoding.  Must only set SRDY explicitly
    SRDY = 0;                   " SRDY not ready while refreshing

         IF (RESET)     THEN DRAM_Idle          " On reset, go to start state
    ELSE                     DRAM_Idle;         " Done, can go back to idle

STATE DRAMWriteStart:           " Starts access to DRAM with MUX set to transmit row

    " No-output state encoding.  Must only set SRDY explicitly
    SRDY = 0;                   " SRDY not ready while refreshing

         IF (RESET)     THEN DRAM_Idle          " On reset, go to start state
    ELSE                     DRAMWriteRow;      " Get row address for read


STATE DRAMWriteRow:             " Sets RAS and WE for write

    " No-output state encoding.  Must only set SRDY explicitly
    SRDY = 0;                   " SRDY not ready while refreshing

         IF (RESET)     THEN DRAM_Idle          " On reset, go to start state
    ELSE                     DRAMWriteCol;      " Get column address for write


STATE DRAMWriteCol:             " Sets CAS and WE for write

    " No-output state encoding.  Must only set SRDY explicitly
    SRDY = 0;                   " SRDY not ready while refreshing

         IF (RESET)     THEN DRAM_Idle          " On reset, go to start state
    ELSE                     DRAMWrite;         " Clear WE which will perform write


STATE DRAMWrite:                " Deactivates WE for write

    " No-output state encoding.  Must only set SRDY explicitly
    SRDY = 0;                   " SRDY not ready while refreshing

         IF (RESET)             THEN DRAM_Idle          " On reset, go to start state
    ELSE                             DRAM_Idle;         " Go to start state, done writing


STATE DRAMReadStart:            " Starts access to DRAM with MUX set to transmit row

    " No-output state encoding.  Must only set SRDY explicitly
    SRDY = 0;                   " SRDY not ready while refreshing

         IF (RESET)     THEN DRAM_Idle          " On reset, go to start state
    ELSE                     DRAMReadRow;       " Get row address for read



STATE DRAMReadRow:              " Sets RAS for read

    " No-output state encoding.  Must only set SRDY explicitly
    SRDY = 0;                   " SRDY not ready while refreshing

         IF (RESET)     THEN DRAM_Idle          " On reset, go to start state
    ELSE                     DRAMReadCol;       " Sets CAS for column addr


STATE DRAMReadCol:              " Sets CAS for read

    " No-output state encoding.  Must only set SRDY explicitly
    SRDY = 0;                   " SRDY not ready while refreshing

         IF (RESET)     THEN DRAM_Idle          " On reset, go to start state
    ELSE                     DRAMReadWait;      " Wait state to satisfy read cycle time


STATE DRAMReadWait:             " Wait to satisfy read cycle time

    " No-output state encoding.  Must only set SRDY explicitly
    SRDY = 0;                   " SRDY not ready while refreshing

         IF (RESET)             THEN DRAM_Idle          " On reset, go to start state
    ELSE IF (!MCS2 & !DTR)      THEN DRAMReadStart      " Another read cycle
    ELSE                             DRAM_Idle;         " Done reading












TEST_VECTORS
"                                              St3, St2, St1,  St0
( [ Clock, RESET, MCS1, MCS2, DTR ] -> [ SRDY, MUX, CAS, RAS, DRAM ])

" Refresh cycle
  [   .C.,     0,    1,    1, .X. ] -> [    1,   0,   0,   0,    1 ]; " Nothing happening
  [   .C.,     0,    0,    1, .X. ] -> [    0,   0,   1,   0,    1 ]; " CAS-before-RAS (CAS)
  [   .C.,     0,    0,    1, .X. ] -> [    0,   0,   1,   1,    1 ]; " CAS-before-RAS (both)
  [   .C.,     0,    0,    1, .X. ] -> [    1,   0,   0,   0,    1 ]; " Done refresh, idle
  [   .C.,     0,    0,    1, .X. ] -> [    0,   0,   1,   0,    1 ]; " Another refresh
  [   .C.,     0,    0,    1, .X. ] -> [    0,   0,   1,   1,    1 ]; " Still refreshing
  [   .C.,     0,    1,    1, .X. ] -> [    1,   0,   0,   0,    1 ]; " Idle

" Read cycle
  [   .C.,     0,    1,    0,   0 ] -> [    0,   1,   0,   1,    1 ]; " Start mux direction
  [   .C.,     0,    1,    0,   0 ] -> [    0,   0,   0,   1,    1 ]; " Reading, WE inactive, RAS
  [   .C.,     0,    1,    0,   0 ] -> [    0,   0,   1,   1,    1 ]; " RAS and CAS
  [   .C.,     0,    1,    0,   0 ] -> [    0,   0,   0,   0,    1 ]; " Wait state
  [   .C.,     0,    1,    0,   0 ] -> [    0,   1,   0,   1,    1 ]; " Start mux direction
  [   .C.,     0,    1,    0,   0 ] -> [    0,   0,   0,   1,    1 ]; " Reading, WE inactive, RAS
  [   .C.,     0,    1,    0,   0 ] -> [    0,   0,   1,   1,    1 ]; " RAS and CAS
  [   .C.,     0,    1,    0,   0 ] -> [    0,   0,   0,   0,    1 ]; " Wait state
  [   .C.,     0,    1,    1, .X. ] -> [    1,   0,   0,   0,    1 ]; " Done

" Write cycle
  [   .C.,     0,    1,    0,   1 ] -> [    0,   1,   0,   1,    0 ]; " Start mux direction
  [   .C.,     0,    1,    0,   1 ] -> [    0,   0,   0,   1,    0 ]; " Writing, RAS
  [   .C.,     0,    1,    0,   1 ] -> [    0,   0,   1,   1,    0 ]; " CAS and RAS
  [   .C.,     0,    1,    0,   1 ] -> [    0,   0,   1,   1,    1 ]; " WE goes inactive
  [   .C.,     0,    1,    0,   1 ] -> [    1,   0,   0,   0,    1 ]; " Goes to idle for one clk
  [   .C.,     0,    1,    0,   1 ] -> [    0,   1,   0,   1,    0 ]; " Start mux direction
  [   .C.,     0,    1,    0,   1 ] -> [    0,   0,   0,   1,    0 ]; " Writing, RAS
  [   .C.,     0,    1,    0,   1 ] -> [    0,   0,   1,   1,    0 ]; " CAS and RAS
  [   .C.,     0,    1,    0,   1 ] -> [    0,   0,   1,   1,    1 ]; " WE goes inactive
  [   .C.,     0,    1,    1,   1 ] -> [    1,   0,   0,   0,    1 ]; " Done

" Wait
  [   .C.,     0,    1,    1, .X. ] -> [    1,   0,   0,   0,    1 ]; " Idle
  [   .C.,     0,    1,    1, .X. ] -> [    1,   0,   0,   0,    1 ]; " Idle

END
